# Node Commands
* mark Node unschedulable
    `kubectl cordon $NODENAME`
* node status
    `kubectl describe node <insert-node-name-here>`
* pods status
  `kubectl get pods` shows the status of the pods
  * individual node
      `kubectl describe <pod>`
* `kubectl convert` for migrate manifests to a non-deprecated api version with newer Kubernetes release.
* Create deployment
  ```console
  kubectl create deployment hello-node --image=k8s.gcr.io/echoserver:1.4
  kubectl get deployments
  kubectl get pods
  kubectl get events
  kubectl config view
  # Get kubeconfig
  kubectl config view
  ```
* Create a Service
To make the container accessible from outside the Kubernetes virtual network, you have to expose the Pod as a Kubernetes Service.
  ```console
  kubectl expose deployment hello-node --type=LoadBalancer --port=8080
  kubectl get services
  ```
* Clean up
  ```console
  kubectl delete service hello-node
  kubectl delete deployment hello-node
  ```
* Shared resources in a Pod
  * Shared storage, as Volumes
  * Networking, as a unique cluster IP address
  * Information about how to run each container, such as the container image version or specific ports to use
* Pods are the atomic unit on the Kubernetes platform.
* Troubleshooting
  ```console
  kubectl get - list resources
  kubectl describe - show detailed information about a resource
  kubectl logs - print the logs from a container in a pod
  kubectl exec - execute a command on a container in a pod
  ```
* Each Pod in a Kubernetes cluster has a unique IP address, even Pods on the same Node, so there needs to be a way of automatically reconciling changes among Pods so that your applications continue to function.
* Although each Pod has a unique IP address, those IPs are not exposed outside the cluster without a Service.
* Services can be exposed in different ways by specifying a **type** in the ServiceSpec:
  * *ClusterIP* (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster.
  * *NodePort* - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using <NodeIP>:<NodePort>. Superset of ClusterIP.
  * *LoadBalancer* - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort.
    
## Services and Labels
* Example command:  
  `kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}'`

## Scaling apps
* To see the ReplicaSet created by the Deployment  
  `kubectl get rs`
* Scale the deployment to 4 replicas  
  `kubectl scale deployments/kubernetes-bootcamp --replicas=4`
* Number of pods with IP  
  `kubectl get pods -o wide`

## Performing a Rolling Update

# Nana kubernets
* Features
  * no downtime
  * scalability
  * Disaster recovery
## Kubernets Componenets
* Node and pod
  * pod is a kind of abstraction over containers
  * Usually 1 appliation per pod
  * each pod gets its own IP address
  * new IP address will be assigne when re-creation pod
* Service
  * permanent IP address
  * Lifecycyle of service and pod are indepedent
  * External service
* Ingress
  * forward request to service
* ConfigMap and Secrets
  * ConfigMap Refer to the other pods URL, etc
  * Secret: username/password
* Volumes
  * data storage - k8s doesn't manage data persistence!
* Deployment and statuful set
  * Deployment - define blueprint of the pods
  * DB is not able to use deployment - since it has a state
    * stateful set
## K8s architecture
  * Node process
    * 3 processes have to be installed on the Node
      * container runtime
      * kubelet
      * kubeproxy forward the requests
    * processes run on every master node
      * API server - cluster gateway
      * scheduler
      * controller manager - detects cluster state changes
      * etcd - cluster brain -cluster changes get stored in etcd
## Commands
  ```console
  kubectl create deployment nginx-deployment --image=nginx
  kubectl edit deployment nginx-deployment
  kubectl describe podName
  kubectl exec -it mongo-56ddbb9dc8-fwwbx bash
  kubectl describe service nginx-service
  kubectl get pod -o wide
  kubectl get deployment nginx-deployment -o yaml
  ```
## Configuration Files
* echo configuration has 3 parts
  * metadata
  * specification to kind
  * status - auto generated by k8s (desired = actual?)
## Labels and Selectors
## Namespaces
* Four scenarios
  * Resources groups in Namespaces
  * Conflict: many teams, same application
  * Resource sharing: staging and development
  * Access and resource limits on Namespace
    * limit CPU, RAM, storage per NS
* Each NS has to define it's own ConfigMap
* Access service in another namespace
## K8S Ingress
* Need an implementation for Ingress
  * Ingress Controller
  * Config default backend
  * Config TLS certificate for cluster
## Helm explained
```console
helm search <keyword>
helm install --values=my-values.yaml <chartName>
helm rollback <chartName>
```
* Templating engine
  * A template file with multiple values.yaml files
## k8s volumes
* storage has to be available on all nodes
  * persistence volume
  * persistence volume claim
  * storage class 
* Pods requests the volume through the PV claim
  * claim try to find a volume in cluster
  * volume has the actual storage backend
  * claim must in the same namespace
    * volume is mounted into the pod
  * Storage class privisions PV dynamically
## Statefulset
* Stateful applications deployed by statefulset
* Next pod will be created only previous on get created and running
* predictable pods name
* fixed individual DNS name
## Services
each pod has its own IP address
Services:
  service has a stable IP address
  loadbalancing
* ClusterIP Services
  * default type
  * Which pods to forward the request to?
    * selector
  * whic port to forward request to?
    * targetPort
  * service endpoints
    * k8s creates endpoint object for service
      * `kubectl get endpoints`
      * track which pods are the members of the service
* Headless services
  * Client wants to communicate with one specific pod directly
  * Define clusterIP as None, no cluster IP address is assigned
* NodePort
  * External traffic has access to fixed port on worker node
  * NodePort services not secure
* LoadBalancer services
  * NodePort and ClusterIP will be created automatically
  * Nodeport will only be accessiable from LoadBalancer
* LoadBalancer service is an extension of NodePort Service
* NodePort service is an extension of ClusterIP service